===Some chat with ChatGPT===
What does ReactDOM.createRoot
ReactDOM.createRoot is a method in the React library that creates a root container for a React tree. It's used to render a React app to a specific DOM node in the document.

The method takes one argument: the DOM node that you want to render your React app into. For example:

javascript
Copy code
const rootContainer = ReactDOM.createRoot(document.getElementById("root"));
rootContainer.render(<App />);
The createRoot method returns a root container object that has a render method that you can use to render your React components into the specified DOM node. You can call render multiple times to update the React tree and re-render the DOM.

createRoot is part of the React DOM library and it's specifically designed for server-side rendering and hydration of React apps. It provides a way to create a root container outside of the main render tree, which can be useful for improving performance and isolating components that need to render independently.




Girik Garg
What does rootContainer.render(<App />);
do
The code rootContainer.render(<App />) is rendering a React component into the DOM using a root container created by ReactDOM.createRoot.

rootContainer is an object returned from a previous call to ReactDOM.createRoot, and render is a method on that object. The argument to render is a React component represented by the <App /> syntax.

The render method takes a React component and renders it into the DOM node that was specified when the root container was created. The result of the render method is a fully-mounted React component tree that updates dynamically as the components' state changes.

In other words, the code rootContainer.render(<App />) is rendering the App component into the DOM node specified by the root container, and it's the starting point for a React app. Any updates to the component state will trigger a re-render of the DOM and keep the UI in sync with the underlying data.


===MY SELF NOTES STARTS===

<!--Anything we can generate on server like parcel-cache or node_modules should be in gitignore, but package-lock.json can't be put in gitignore-->
        <!-- React is not fast only because of virtual DOM but because of bundlers (like parcel or vite or webpack)-->
//dist folder stores the minified files 

We have a package manager which takes care of our transitive dependencies (transitive dependecies means dependecies which can further have even more dependencies)

"browsersList":[
    "last 2 versions"]
  } ensures that my app is compatiable with last 2 versions of all browsers avaialble on broswerslist.dev

  babel is used for creating polyfill
  polfyfill means replacing code with the code that browser understands
  eg. if older version of JS doesn't understand map() function, babel may write own custom implementation of map() so that code is able to execute

  tree shaking means that if I am importing a library,library may provide 10-20 functions, but I may be using only 1 or 2 of them. So parcel is smart enough and it removes the code of the unused libraries.

  babel-plugin-transform-remove-console is used for removing the console.log statements from the production code.

  .babelrc is a configuration for babel

  Whenever there there is an array in createElement like const container=React.createElement(
                "div",{
                    id:"container",
                }, [heading1,heading2]
    ), I need to use key in my props.

Updating something in DOM is called rendering

Why do I need to use key as a prop? See from the docs https://reactjs.org/docs/reconciliation.html: I will explain briefly
If I change my code from:
<ul>
  <li>first</li>
  <li>second</li>
</ul>

to:
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>

then React has to do a lot of work in rerendering, because React just knows that another li has been added. But if I add keys, React knows which new li tag has been added, so it doesn't have to spend that much time and performance of React improves.

React.createElement gives us an object which is then converted to HTML code and placed on the DOM React.createElement=>Object=>HTML (DOM)

JSX is used because for a complicated structure React.createElement code becomes lengthy and complicated when there are multiple children

JSX is HTML-like syntax but not HTML inside Javascript.

ID is a HTML concept but key is a concept from React

Babel is a JavaScript library which internally uses React.createElement from JSX

So the flow goes like:  JSX -> React.createElement -> Object-> HTML (mounted on DOM)

babel is installed along with parcel
there is second package-lock.json in node_modules which has details about versions of all transitve dependcies (babel is present in node_modules )

tilde (~) notation: It is used to match the most recent patch version. Tilde ~ notation freezes the major version and minor version. As we know patch updates are bug fixes that’s why we can say ~ notation allows us to automatically accept bug fixes.

Caret (^) notation: It is used for automatically updating the minor updates along with patch updates. 

Everything is a component in react

Reaction based components:functional based components (new, will be taught) and class based components  is the old way of writing code

Functional based component is nothing but a normal Javascript function which can either return JSX or a React element using React.createElement

Component name starts with capital letter-- this is not mandatory but a convention

When I use a function based component, the I use the syntax as root.render(<FunctionalComponent/>)

Difference between React element and component: 
const heading=(
    <h1 id="heading3" key="abc"> Namaste React </h1>
) this is a react element but 

const heading=()=>{
    return <h1 id="heading"> Namaste React</h1>
} this is a React component (function based component)

React element at the end of the day is an object and a React functional based component is a function.

We can execute any JS code (any JS aexpression not statement) inside curly braces {console.log("Hello")} inside the React component
for example, the code {
  let a=10;
  console.log(a) will not work, because these are two js statements
}
but if we convert it into a js expression, something like ((a=10),console.log(a)) it will work

If I have an API that has some malicious code inside it let's call it data, and if it is called inside the React component like {data}, then malicious code gets excuted, this is known as cross site scripting. But JSX does something called sanitisation, it makes sure that the code is secure

Component compposition is nothing but placing a component inside another component

React function is also hoisted because it is also Jaavscript function at the end of the day 

ES6 is not manadatory

<Title/> is the most common syntax for using functional components, it is known as self closing tags

Very important point: each JSX element must have only one parent element so const jsx=<h1> Hi<h2> Hello </h2></h1> is invalid syntax, it shoud be wrapped inside a div like const jsx=<div><h1> Hi<h2> Hello </h2></h1> </div>

If I don't use React Fragment then the structure looks something like <div id="root"> <div> <h1> Hi </h1> <h2> Hello</h2></div></div>, the div inside div is ugly, so we use react fragement

react fragment is a component that is exported from react, if used then the strcuture looks like 
<div id="root">  <h1> Hi </h1> <h2> Hello</h2></div>, the extra div gets eliminated

for multiple elements, I can use either div or react.fragment

React.fragment is like an empty tag
React.fragment is written in short form as <>

<div style={styleObject}>
Inline styling in react, we need to pass javascript object, another way it to give the div a class with className and define the style in style.css file

Config driven UI: The frontend website is displayed using the data sent by API on backend. 
example : swiggy in bengaluru might have 10% discount and in delhi may have 50% discount

config driven UI is a huge plus point in interviews
Carousel are those images like 50% off etc which appeaer on top

Optional chaining?. TODO

props (shorthand for properties): passing props meaning passing data/properties into a component

React bundles all the passed parameters into a single object called props

{restaurant} means destructuring the props

... is spread operator in javascript which spreadss the contents of the array

Virtual DOM is not only used in React, it is a software engineering concept, virtual dom is a representnation of the DOM in our code

React does something known as reconiciliation, reconciliation uses diff algorithm to find out differences between actual DOM and virtual DOM and rerenders that small part which is different in the real DOM and virtual DOM

Whenever there are multiple tags of same type (all h1 or all div), then React doesn't know which new div has come, it will rerender all the div's because it can't distinguish between them, but by using a unique key with each div, React knows which div to re-render and so the performance of React app improves

Virtual DOM is not the actual DOM, it is a representnation of DOM

Diff algorithm finds out the difference between the DOM and virtual DOM (just like git diff)

After Rect-16, React introduced a new reconciliation engine called React Fiber

Never use index as a key in react

No key (not acceptable) <<<<<index key (okay way,use only if you don't have anything) <<unique key (best practice)

There are two ways to export in javascript: one of them is using export default
export defualt is just used to export one function.

exporting by default vs exporting by name: syntax for export by name is export const Title=()=>{
  function body
}
while importing a js file exported by name, the syntax will be import {Title} from './components/Header.js' (this is called as named import)

import {Title} from "./components/Header": This is not object destructuring, although it looks like object destructuring

import * as obj from "./components/Header": for importing all functions and then use a particular function like obj.Title

Using import from "./components/Header" or "./components/Header.js"

Some developers even prefer to use Header.jsx instead of Header.js because it contains jsx code, even that works absolutely fine.

The config file is used to put the hardcoded things of the project

If I create a search button using 
const txt="Girik"
<input type="text" className="search-input" placeholder="Search" value="{txt}"></input>, it will not accept any data from the user, the reason being that React uses one way binding, meaning that data can only flow from the code to the user but not from the user to the code

One way data binding is actually good in a sense that it makes our app predictable, because we might be using that variable at many places in the code, so the value can be changed by different values. But it creates a problem for us because we can't take input from the user. 
so I need to use onChange attribute for this function, something like: TODO

whenever I have changing variables in React, I need to use a kind of React variable called state variables (every component in React has a state)

React hook is just a javascript function at the end of the day and these functions give us some functionalities.


useState hook: const [searchText]=useState()
useState hook return an array [variable name, function to update the variable]
what is use of function useState? to create local state variables

I can't directly set the variables in the react component, I need to use function provided by useState(), something like:
const [searchText,setSearchText]=useState("KFC") and then use the function setSearchText 

in the onChange function as a callback function in: onChange={(e)=>
        {setSearchInput(e.target.value)} 
       } 

Interview question: why do we need state variables when I have local variables?
if I use a local variable let var1=11, and if I update the variable var1 to some other value like 12, then React component would not come to know that the value of local variable has been updated

So React says that at any time if we want the variables to be in sync with the UI, we need to use state variables

Entire component is re-rendered, so if we print ('render'), it will get printed (from 6th chapter of React, exploring the world 1 1080pixel), 

Whenever there is any change in the state, React quickly rerenders the entire component gets

Important concept in industry: microservices
Swiggy/uber is not made of single React app etc

In earlier days: in same project, aws, ui (jsp pages) and code to send SMS was there
for just one icon change, they had to deploy the whole project
This is called monolith architecture

The world  (newer companies are moving towards microservices architecture)

Microservice App: Separate projects for UI, logs, SMS etc
Let's say UI is running on port 1234 and API is working on port 1235
advantage: 1) seperation of concern (important term): we don't need to worry about the other microservices, what they are doing or not

The different microservices can be written in different languages like UI can be written in React, backend can be written in Java, etc

What we are making in this project is the UI microservices

So the different mictoservices can be hosted on different ports (or different URLs too):
like swiggy.com (UI) on port 3000
swiggy.com/api on port 4000
swiggy.com/notifications on port 5000

or it can be like github.com or api.github.com

Exploring the world means communication between UI microservice and API microservice

const Body = () => {
  IMPORTANT: if I call fetch() here, it will rerender on each UI update
  // const searchTxt="KFC"
  //searchText is a local state variable
  const [searchText,setSearchInput]=useState("") //to create state varibable
  return (
    <div> .....</div>
  )

There are two ways:
1) the website request is made->make an API call (say, it takes about 300 ms)->render page in React (say it takes 200 ms ) in total takes about 500 ms

2) the website request is made-> show some intial page (maybe even render the page)->make the API call-> update the UI (takes 300 ms in total let's say)

second way is a better way due to enhancing user experience

useEffect is a hook for accomplishing the second way (rendering a page first, call and API and then updating in the UI)

in useEffect() function, we pass a callback function so the syntax looks something like:

useEffect(()=>{
  callback function body
})

callbac function means that the function will not be called immediately, it will be called when useEffect wants to call it

so using useEffect hook, the function for API call will be called after the code of UI has executed (the second case which we discussed above)

useEffect is imported using named import from "react"

When will component render? 2 ways: state changes or prop changes

Now there's a catch: we don't want to call the callback function after every re-render, so we use a dependency array

so overall syntax of useEffect looks like
useEffect(()=>{
  console.log("render")
},[])

use case: we want to cal useEffect only when searchText is changed

If dependency array is empty then that component will not re-reneder for any update

If empty dependency array, then console.log() will be called once after render
if dependendcy array is [searchText], then it will be called once after intitial render and everytime after render (every time searchText changes)

The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called is undefined or null, it returns undefined instead of throwing an error.

When we open swiggy.com, we see some empty boxes at the first and then the restaarant cards appear
This is done to improve user experience so that the data does not appear all of a sudden on the page after the loading rotating in circular fashion

This is known as shimmer effect : https://blog.logrocket.com/implement-shimmer-effect-flutter/#:~:text=What%20is%20a%20shimmer%20effect,when%20the%20data%20is%20available. Read more about it here

Conditional rerendering: means if restaurant is empty, then load shimmer UI otherwise load actual UI

Diff algorithm is defined in React not react-dom (diff algorithm is same in react-dom and react-native for mobile applications)

If I don't specify any dependency in the useEffect hook, something like useEffect(function), it assumes dependency on each variable, so it will be called after every re-render but for empty array [], useEfffect will be called only during initial render

It's not a good idea to define a component inside another component, for example, the following code is not good:

const appLayout=()=>{
  const func=(){

  }
}
Reason: every time there is a change in appLayout, func will be rerendered too

Never use a useState hook inside a for loop or if condition(because it leads to inconsistencies)
Never use useState outside the functional component

It is completely fine to use multiple useEffect inside a functional component, but perforemance of app will go down

For using routing in React, there can be different types of routers (available in documentation) but most commonly we use createBrowserRouter 

while specifying the routing, we use path and element, path specifies the path like '/about' and element specifies which component is to be used

Just using createBrowserRouter from react-router-dom won't work because we need to provide thr router to the app, so we use, for this we use RouterProvider compoennt from react-router-dom


useRouteError is a hook provided inside react-router-dom which returns an object containgin detailed information abput why rotuing failed

Single Page applications(SPA's): in earlier days, there used to be different pages for different pages of the website lie website.com/about.html or website.com/contact.html: a network call had to be made for visiting different pages on the same website: but this is not the case with single page applications

Two types of routing in React: client side routing and server based routing
Server based routing: the new page will come from the server
client side routing: we don't make a network call, all the components are already there in the code

One way to place a link could be with anchor tag <a>, but that would reload the entire page (server side reloading)
to prevent this I use client side routing with "Link" from react-router-dom

The syntax is something like:
import { Link } from "react-router-dom"

<li> <Link to="/about"> About </Link> </li>

Behind the scenes, Link also uses anchor tag <a> (if we see in the console), but using Link from react-router-dom has the advantage that it keeps track of all the links (just like useState keeps track of all state variables)

The problem with the app till now is that if I load the about us page, the header and footer page will disappear, but I want header and footer to be there on each page, so <Header> </Header> {Outlet code} <Footer> </Footer>, the outlet code will be the code which is actually rendering according to the page (whether it is "/" or "/about" )

For using Outlet, we use Outlet from "react-router-dom"

All the children which we specify in the routing configuration will be passed to <Outlet/> according to the route used (We can call it conitional routing )

Dynamic routing: the routes are not hardcoded, but they vary according to which link I am clicking. Like on swiggy.com, if I click restaurant sagar-ratna, link will be swiggy.com/sagar-ratna and if I click on Gopal, link will be swiggy.com/Gopal

I want to build a functionality where if I visit the route localhost:1234/restaurant/123 I get the message "Welcome to restauarnt 123" and if I visit localhost:1234/restaurant/124, I get the message displayed as "Welcome to restuarnt 124"

For implementing this functionality I need to know the params which were passed, so there's a hook which is known as useParams which enables me to get the param "123" or "1234" etc

Modularity makes the code understandable, testable, readable and maintainable

===CLASS BASED COMPONENTS===
React intially started with class based components, initially there was no concept of functional based components and hooks.
Class based components makes the code somewhat messier, and it is not used in upcoming new projects, but maybe used in legacy codes.

Class based components are highly asked in interviews 

Class based components are javascript classes at the end of the day. 
The syntax for using a class based component is something like:
class Profile extends React.Component{ //I need to write extends React.component so that JS can understand it is different from a normal class (the class Profile is basically inheriting some properties from React.component)

  render() { 
      return <h1> Profile class component </h1> // return jsx
  } //calling render is the most important aspect of any class based component
  export default Profile;
}

In a class based functional component, the props are accessed as: {this.props.name} 
React attached the props to the class

For a class based functional component,for passing props, we have to define the state (similar to useState functional hook), inside the constructor of the class, and inside the class define this.state, and inside this.state define the variable like count, the sample code is given below:

constructor(props){
        super(props);
        //create state
        this.state={
            count:0,
        };
    }

If I have to create another state variable count2 in the code, it will be maintained in the same this.state object

Even using multiple useState internally maintains a single big object 

For using setCount in class based components, we use setState() method provided by JavaScript. WE CAN'T DIRECTLY MUTATE THE STATE VARIABLE, SYNTAX LIKE this.state.count=1 is INVALID

reconciliation algorithm works the same way for both class based and functional based components

So, in a class based component, we can change all the state variables with the help of a single setState() method

Order of execution in a class based component:
the constructor is called first, and then the class based functional component is called 

Now in order to mimic the useEffect functional hook (first of all, in esssence what a useEffect hook does is that the component gets rendered first and then the useEffect is called), so in class based components we have componentDidMount() function which is called after the render of the component.

The order of executionis : constructor first, then the component is rendered and then componentDidMount is called (this is known as lifecycle of React component)

Order of lifecycle method caling when parent and two children are there: (confusing question):

What I mean is something like 

Whenevr react is ernedeirng anything, two phases: first phase is render phase and second one is commit phase


First understand what exactly is meant by rendering of a component and mounting of a component.....https://www.quora.com/What-does-the-term-render-mean-in-ReactJS-Like-render-a-component In a nutshell, rendering is the process of transforming your react components into DOM (Document Object Model) nodes that your browser can understand and display on the screen.

DOM manipulation is extremely slow. In contrast, manipulating React elements is much, much faster. React makes the most of this by creating a virtual representation of what the DOM should look like called the Virtual DOM[1].

Whenever you make any changes to your running React application, such as entering text, removing an element, adding an element, etc, React will batch all of these changes together in its Virtual DOM, then compare this representation with the actual DOM, find what needs to be updated, and then make the smallest possible changes to the real DOM to keep them in sync while keeping the application performant.


===Meaning of mounting a component===
https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js

React does so by "mounting" (adding nodes to the DOM), "unmounting" (removing them from the DOM), and "updating" (making changes to nodes already in the DOM).

Mounting a component in React is done on the virtual DOM, which is an in-memory representation of the actual DOM. The virtual DOM is a lightweight, high-performance representation of the DOM that allows React to make updates to the DOM in an efficient and performant manner.

When a component is mounted in React, it creates a virtual DOM node for the component and all its children. This virtual DOM node is then compared to the previous virtual DOM representation for the same component (if it exists), and React calculates the minimum number of changes needed to update the actual DOM to match the new virtual DOM representation. These changes are then made to the actual DOM, which updates the component's appearance on the screen.

The use of the virtual DOM is one of the key features that makes React such a fast and efficient framework for building user interfaces. By doing the majority of DOM updates in memory, React can ensure that the actual DOM updates are minimized, which results in faster and smoother user experiences.

As making  changes in the actual DOM is a heavy operation, React tried to firstly render all the components (parent component, first component and second component), so the order of execution is like: parent component constructor, parent component render, first compomemt constructor, first component render, second component constuctor, second component render

Now, when the time comes to make the changes in the actual DOM, first component will firstly make the changes, so first component Did Mount will be called first (Because of FIFO order), then second DidMount will be called and at last parent componentDidMount will be called (parent will be called at last, because it is the parent of both the components, so it won't see FIFO order )

--IMPORTANT QUESTION ASKED IN SENIOR REACT interviews
Why can you not pass an async function directly into a React useEffect call? i.e. why something like useEffect(async f) is not allowed?

Answer taken from here: https://ultimatecourses.com/blog/using-async-await-inside-react-use-effect-hook#:~:text=Why%3F,function%20will%20never%20get%20called.

This WORKS, but you should avoid it. Why? Because React’s useEffect hook expects a cleanup function returned from it which is called when the component unmounts. Using an async function here will cause a bug as the cleanup function will never get called. 

So what excatly is a cleanup function? 

React’s useEffect cleanup function saves applications from unwanted behaviors like memory leaks by cleaning up effects. In doing so, we can optimize our application’s performance. 

Just like the name implies, the useEffect cleanup is a function in the useEffect Hook that allows us to tidy up our code before our component unmounts. When our code runs and reruns for every render, useEffect also cleans up after itself using the cleanup function.

The useEffect Hook is built in a way that we can return a function inside it and this return function is where the cleanup happens. The cleanup function prevents memory leaks and removes some unnecessary and unwanted behaviors.

ComponentDidUpdate() function is called when the component is already mounted on the DOM (the node for that component already exists in the DOM but there is some update like when we change the state using setState function)

componentDidMount will be called during first render and componentDidUpdate will be called when DOM is getting updated (this is exactl similar to what we did in useEffect, but we don't have to make the componentDidMount and componentDidUpdate functions)

there's a componentWillUnmount function too, it is called when the component is unmounted from the DOM (eg when I switch to some other page )

ONE IMPORTANT NOTE: DON'T COMPARE LIFECYCLE METHODS WITH FUNCTIONAL BASED COMPONENTS, LIKE DON'T SAY useEffect is equivalent to componentDidMount method 

If I had to mimic something like useEffect(,[count1,count2]) in class based functional components, it would be something like:

componentDidUpdate(prevProps,prevState){
  if (this.state.count1!===prevState.count1 || this.state.count2!===prevState.count2){
    //code: so this way of writing code is a pain
  }
}


===DISCUSSED IN LECTURE===
What is the use case of componentWillUnmount?
Our application has one page (single page application), when we aree clicking on Home,About, Contact etc then only the component is getting changed, the page is not getting changed


changedsetInterval(()=>{
            console.log("Namaste React OP")
        },1000)
        console.log("componentDidMount")
}
For answering why componentWillUnmount is needed (what type of cleanup is performed), consider the above code from ProfileClass.js file 

There's a slight disdavantage with SPAs that let's say if I navigate from About to Contact page etc, then Namaste React OP will be getting printed, even though I left the About page

So I need to use clearInterval in the componentWillUnmount function, by doing so the interval stops getting printed in the console when I am on some other component like Contact Us. (this is best way to explain usecase of componentWillUnmount to interviewer)

I can mimic something similar in the useEffect hook too, let me use a setInterval function in useEffect hook too (see the profile.js file), the "Girik Garg OP" will keep on getting printed even if I navigate to some other page like Contact Us.

So in order to mimic the effect of unmounting, I can return a callback function from the useEffect


===CH-9 OPTIMIZING OUR APP===
We are going to create our own hook. Questions that might come in mind: when to create custom hook, why to create hook and how to create custom hook?

Reasons to use custom hook: It helps to achieve reusability (we can use the same function again) and readabaility.

Optimising the app structure: I am using utils folder for all the helper functions, where I can keep all the helper functions like filterRestaurants etc

Difference between a custom hook and a functional component: a functional component is a JS code that returns some JSX but a hook need not return any JSX, it performs some task (like maybe fetching data of restauarant from API)

Window event online is defined in Javascript which can be used to see whether the user is online or not (to develop a functionality 'you've gone offline' when user has gone offline)

Why we don't use a normal Javascript function for this functionality instead, I use a hook? Because the state is changing here,and normal function will not have a provision of changing the state, but a hook has functionality of changing of states  


Why did we return a function from our effect? This is the optional cleanup mechanism for effects. Every effect may return a function that cleans up after it. This lets us keep the logic for adding and removing subscriptions close to each other. They’re part of the same effect!

And

When exactly does React clean up an effect? React performs the cleanup when the component unmounts. However, as we learned earlier, effects run for every render and not just once. This is why React also cleans up effects from the previous render before running the effects next time. We’ll discuss why this helps avoid bugs and how to opt out of this behavior in case it creates performance issues later below.

===NEED FOR CONCEPT OF CHUNKING/CODE SPLITTING/LAZY LOADING (THEY ARE ALL ONE AND THE SAME THING) ====
PARCEL (OR ANY OTHER BUNDLER LIKE VITE OR WEBPACK)  BUNDLES ALL OUR FILES INTO ONE COMPRESSES JAVASCRIPT FILE, BUT LET'S SAY A WEBSITE  LIKE MAKEMYTRIP.COM HAS GOT 100S OR 1000S OF COMPONENTS, SO IT DOESN'T MAKE SENSE TO BUNDLE ALL THE COMPONENTS INTO A SINGLE JS FILE

IF A PERSON IS GOING TO MMT, THERE ARE HIGH CHANCES THAT THEY WILL GO TO BOOK A FLIGHT, SO WE CAN LAZY LOAD OTHER COMPONENT LIKE BUS  (LAZY LOAD THE COMPONENT WHICH HAS CODE FOR THE BUS)


SO BY CHUNKING/CODE SPLITTING/LAZY LOADING/ON DEMAND LOADING/ DYNAMIC IMPORT , WE LOGICALLY SPLIT THE SINGLE MINIFIED FILE INTO MANY FILES
CODE SPLITTING IS BENEFICIAL FOR SYSTEM DESIGN INTERVIEWS 

Storing the images in CDN, caching the images: these are keywords that interviewer loks for in system design interviews

In orderoyt do lazy loading, we use Lazy component from "React", as a named import.  

The lazy function takes a callback function, and this callback function lazily imports the required component. 

Whenever we are trying to load a component in-dermand, React tries to suspend it. (because code takes some time to fetch the code of the laxy component,let's say 20 ms, but React tries to render it even before 20 ms)

In order to solve this issue, we React provides a library called "Suspense" from "React", if I wrap the element inside Suspense, React takes special care about the lazily loaded components. 

fallback prop in Suspense can be used to load a component (like Shimmer) in the meantime the splitted code loads


===Chapter 10====
SCSS (Sassy CSS) and SASS (Syntactically Awesome Style Sheets) is modern way of writing CSS , which then gets compiled to CSS at the end of the day.

One way of using CSS: using className with the component, and then specifying the CSS inside a style.css file

Another way: use inline css, inside the component pass style object. 

Inline CSS is not a good way because it is difficult to maintain, it is not reusable , and job of processing inline CSS is heavy for browser.

Material UI is a library developed by Google (Some other libraries/frameworks are Base UI and Ant Design, Chakra UI, Styled components,Bootstrap (Styled components is many a times used in Node projects )) (there all are also called component libraries)

Tailwind CSS framework

In the older days, there used to be three different files for HTML,CSS and JS. But later on, with React, we started writing HTML like code in Javascript, so styled component was based on the philosophy of using CSS too in Javascript.

Pros of using libraries: 1) Saves time, makes more maintainable components
2) Consistent UI (all button in web app will look same )

Cons of using libraries: 1)Makes bundle size heavy
2) We lose control over components
3) Personal customisation becomes difficult

Some features about tailwind CSS framework:
1) CSS on the go (in the same file)
2) reusability (the code can be reused at many different places)
3) Less bundle size
4) Flexible UI (Customizable, unlike material UI where buttons etc. will remain the way they are)


Every style that we'll write will be a new className in Tailwind CSS.

PostCSS is a tool for transforming styles written in CSS (Cascading Style Sheets) with JavaScript plugins. It allows you to use modern CSS syntax and features, and then transform them into a compatible form for older browsers that do not support the latest CSS features.

PostCSS plugins can perform a wide range of tasks, including:

Transpilation of modern CSS syntax (e.g. using CSS variables or grid layout) to a more compatible form
Minification and optimization of the CSS code
Adding vendor prefixes to CSS properties
Linting the CSS code for syntax and style errors
Automatic generation of fallback styles for older browsers
PostCSS is typically used in combination with other build tools, such as Webpack or Gulp, to process and compile CSS code in a development environment, and then generate the optimized and compatible version for production use.


In the context of a postcssrc file, the rc stands for "runtime configuration". The postcssrc file is used to specify the configuration options for the PostCSS tool during runtime. The file is named with the rc extension to indicate that it is a configuration file used to specify runtime options.

postcssrc is used to tell the bundler (like vite or webpack or parcel) that we will be using tailwind CSS in our project, so please compile it into CSS while bundling up.

Round bracket notation in Tailwind CSS, like w-[200px], helps give width of 200px (this is also knows as dynamic class )

Media queries using tailwind CSS: I write CSS for three types of devices: small,medium,large (phone,tablet and laptop)

Pros of using Tailwind CSS: (important for system design interviews):

easy to use, easy to debug, nu duplicate CSS, bundle size is small, customizable

Cons of using Tailwind CSS: 1) intial high learning curve (new developers will take time to figure out)
2) too many classes, some class names are very ugly

===Data is the new Oil: chapter 11===

Handling data in any application like React app or Angular app is the most critical part of any application.

Web application means an application which is made using a single page application using a library/framework like React/Angular etc, not a plain HTML page

There are two layers in React: Data layer and UI layer 

UI layer is specified using the JSX 

Diff algorithm compares the previous virtual DOM and new virtual DOM, then this difference between the two virtual DOM's is synced with the UI.

The whole UI layer is powered by data layer.

The data is passed in the form of states and props to UI.

Basic question: what is the difference between state and props? State is a local variable whose scope is just inside the component while  props is used to pass data from one component to another component.

Hierarchy of passing the component: Applayout 
-> (state=user)->
 <Body user={user} 
 -> <RestaurantCard user={user}/> 
 -> <h4> User </h4>

 This is known as prop drilling.


 How to pass data from child to parent? Firstly, there would be very less use cases where data needs to flow from child to parent component. 

 What are the ways to pass data from child to parent? 

 Firstly, we can use local storage, but it's not a good option

 Secondly, we could use custom hooks, but using too many custom hooks messes up the code

 Disadvantage of using prop drilling in the code:

 1) makes the code cluttered, if I need to pass data to 10th child then the Hierarchy is too big (passing props is okay upto 2-3 levels)
 2) due to a change in prop, the entire component re-renders, which leads to bad performance of the app

 One way to deal with prop drilling is using Redux, which we'll use in next lecture

We implemented a accordion in the Instamart page 

For making a collapsable accordion, one component't can't directlty change the state of another component, so I use Lifting the state up in React, means the state is shared by the parent of the components

So when to do the process of lifting the state up?. Many times, multiple components must reflect the same changing data. And if the data is not in sync between the "parent and children components" or "cousin components", it is recommended to lift the shared state up to the closest common ancestor.

Let's say child wants to access function x from parent component, so child cannot directly call function x from parent, so parent will pass function x as a prop to the child, and the child can then call function x() as and when required. 



Profiler from React developer tools logs the entire session, and ity is useful while debugging a large scale application.

Flamegraph in Profiler shows actually what happened 

Suppose I have a usecase that I want some data (say a Javascript object) all across the app, one solution is to drill thr prop everywhere, but this is a very bad approach

So whenever I want some data all across the app, one solution is to use local storage (but updating local storage is an expensive operation), so I need to maintaina central state inside the React app.

In case of React, React Context provides the central store, we can also use Redux

Question: Can we not use a global Javascript object which will be accessible everywhere inside the React app? The Disadvantage is that this variable wil not be tracked by React, so reconciliation process will not take place.

To use Context API, I just use a named import of createContext from "react"

In ordet ot use the variable from context, I use "useContext" inside the React app. ("use" for "useContext" and "create" for "createContext", easy peasy stuff)

State and props are tied to components, whereas Context is not specific to any component 

Context is like useState for the entire application

How to use context API in case of class based components? I use ContextName.Consumer (like Usercontext.Consumer)

Using UserContext.Provider I can override the default value

React Router DOM is using context behind the scenes

userContext.displayName="UserContext" //this name will now be displayed in the react developer tools componenets section, so it makes it easier to debug things

===CH-12 LET'S BUILD OUT STORE===

Redux is needed in big projects  (production ready applications) tp mamange the data layer of the React App. 

How dark mode toggle button is made? (click on moon icon, and mode switches to dark mode): It is made possible using Context API, all the components are sharing a state of dark, and once I click on the button, all the components inside the app get the updated state

Instead of creating different contexts, I can use Redux.

For small application, Context API is fine, but for big applications Redux is more fine.

Problems with Redux: installation complex, high learning curve

A bit about history of Redux

In order to make a large scale web applivcation, only using React is not sufficient, we need bundlers, we offload the responsibility of data to Redux and Context API, we need a separate package for testing like Jest


Redux has come up with something called Redux Toolkit, because programmers find it difficult to program it.

All application which we build noweadays involve Redux toolkit rather than Redux

Redux store, at ethe end of the day, is like a big-all object

=> Big object which have different sections, those sections have small pieces

All the components can access Redux store

Redux store is accessible to all components, the web aplication is different from Redux store.

We keep all the data in the Redux store, whether it is authentication related data or cart related information etc

It's not a poor practice to keep all data in the Redux store, because we will create logical partitions (slices) of the store

The technical term for logical partition of Redux Store is known as Slice. (like a cart Slice, user Slice etc)

If I click a + (add item ) button from the UI, I can't directly make changes to the store, I need to dispatch an action, so when we click on the + button, we'll dispatch an item (like the action could be to 'add an item' )

This action will call a function, and then the function will make changes in the particular slices of the store.

Why can't we directly modify the store by clicking on the + icon from the UI? Because in a large scale production ready application, I don't want any random component to change some state, I want to keep track of all the changes.

Data is source of truth, we don't want any component to randomnly change the state, we want to go through a process

The question is similar to asking why don't we use a monolithic architecture to build the applicaton? The answer is separation of concern (Separation of concern is a programming term, and a good word choice for interviews :D ) 

Time for another jargon :D, the function which the action calls, that function is known as reducer


So, finally putting it all in one place, I can say that whenever I click on the + button to add to cart, it dispatches an action, which calls a reducer function, and the reducer function updates the Redux Store

Understanding the architecture of Redux is very important, writing code is secondary thing :)

Now we also want some information from the store, like on Swiggy website, I can see (2 items added to cart)

There's just one more jargon for Redux :D, Selector, if I want to access any item from cart, seelctor wil get the value from Redux store and then pass it to the UI (Number of items added to the cart)

Selector is called so because it is selecting a slice from the store

https://drive.google.com/file/d/1LBmF6_FsvvlaJS7YeMAf9RTigfYwuPtR/view?usp=sharing See this link for a pictorial explanation of the entire concept, it's a very nice images


When we use a selector, it is called "Subscribing to the store" in technical terms, so I can say the cart component has subscribed to the store (means when the store will modify, the cart will automatically modify in the UI)

Selector is a hook (useSelector) at the end of the day, and a hook is a normal function at the end of the day :)

React is different from Redux, many people don't understand the difference between them :)

I need to install two libraries for using Redux, one is @reduxjs/toolkit and the other one is react-redux

Why two libraries are needed? The @reduxjs/toolkit contains the core of Redux like maintaining the store etc whereas react-redux acts like a bridge between React and Redux

As my application and Redux are different (similar in the case of Context API), I need to provide the store to the React App using Provider.

So, in order to provide the store to the React App, I will import Provider from react-redux library.

Redux Tolkit is often shortened to RTK.

 Summary of what we did in Redux to set up the cart:

 1. Create store: using configureStore(): defined in RTK (Redux-toolkit)

2. Provide the store to the app: using <Provider store={store} /> imported from "react-redux"

3. Creating the slice: using createSlice provided by RTK

createSlice({
  name: "",
  intialState: something,
  reducers:{
    addItem: ()=>{ logic },
    removeItem: ()=> {logic}
  }
})

exporting the action using export {addItem,removeItem}=cartSlice.actions;

export default cartSlice.reducer

4. Adding the slice to the store

{
  reducer:{
    cart:cartSlice,
    user:userSlice
  }
}

To dispatch an action in Redux, I use the syntax: dispatch(addItem("Grapes")), this addItem was actually a named import of action in the cartSlice.js file, so wherever I use this action, I need to dispatch the action as well

This dispatch will be provided by a hook known as useDispatch, so the syntax would be something like:  const dispatch=useDispatch(), and this hook useDispatch will be imported from "react-redux"


Very important point asked by Akshay sir in many interviews, how do I subscribe to store in Cart.js? I will use code like useSelector (store=>store.cart.items), I am subscribing to otems array in cart slice of store, there can be performance issues if I just subscribe to store, something like useSelector (store=>store), but this will lead to bad performance, reason being if I subscribe to the whole store, the Cart component will re-render everytime there is a change in the store, but this is not the desired behavior.



