d<!--Anything we can generate on server like parcel-cache or node_modules should be in gitignore, but package-lock.json can't be put in gitignore-->
        <!-- React is not fast only because of virtual DOM but because of bundlers (like parcel or vite or webpack)-->
//dist folder stores the minified files 

We have a package manager which takes care of our transitive dependencies (transitive dependecies means dependecies which can further have even more dependencies)

"browsersList":[
    "last 2 versions"]
  } ensures that my app is compatiable with last 2 versions of all browsers avaialble on broswerslist.dev

  bable is used for creating polyfill
  polfyfill means replacing code with the code that browser understands
  eg. if older version of JS doesn't understand map() function, bable may write own custom implementation of map() so that code is able to execute

  tree shaking means that if I am importing a library,library may provide 10-20 functions, but I may be using only 1 or 2 of them. So parcel is smart enough and it removes the code of the unused libraries.

  babel-plugin-transform-remove-console is used for removing the console.log statements from the production code.

  .babelrc is a configuration for babel

  Whenever there there is an array in createElement like const container=React.createElement(
                "div",{
                    id:"container",
                }, [heading1,heading2]
    ), I need to use key in my props.

Updating something in DOM is called rendering

Why do I need to use key as a prop? See from the docs https://reactjs.org/docs/reconciliation.html: I will explain briefly
If I change my code from:
<ul>
  <li>first</li>
  <li>second</li>
</ul>

to:
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>

then React has to do a lot of work in rerendering, because React just knows that another li has been added. But if I add keys, React knows which new li tag has been added, so it doesn't have to spend that much time and performance of React improves.

React.createElement gives us an object which is then converted to HTML code and placed on the DOM React.createElement=>Object=>HTML (DOM)

JSX is used because for a complicated structure React.createElement code becomes lengthy and complicated when there are multiple children

JSX is HTML-like syntax but not HTML inside Javascript.

ID is a HTML concept but key is a concept from React

Babel is a JavaScript library which internally uses React.createElement from JSX

So the flow goes like:  JSX -> React.createElement -> Object-> HTML (mounted on DOM)

babel is installed along with parcel
there is second package-lock.json in node_modules which has details about versions of all transitve dependcies (babel is present in node_modules )

Everything is a component in react

Reaction based components:functional based components (new, will be taught) and class based components  is the old way of writing code

Functional based component is nothing but a normal Javascript function which can either return JSX or a React element using React.createElement

Component name starts with capital letter-- this is not mandatory but a convention

When I use a function based component, the I use the syntax as root.render(<FunctionalComponent/>)

Difference between React element and component: 
const heading=(
    <h1 id="heading3" key="abc"> Namaste React </h1>
) this is a react element but 

const heading=()=>{
    return <h1 id="heading"> Namaste React</h1>
} this is a React component (function based component)

React element at the end of the day is an object and a React functional based component is a function.

We can execute any JS code inside curly braces {console.log("Hello")} inside the React component

If I have an API that has some malicious code inside it let's call it data, and if it is called inside the React component like {data}, then malicious code gets excuted, this is known as cross site scripting. But JSX does something called sanitisation, it makes sure that the code is secure

Component compposition is nothing but placing a component inside another component

React function is also hoisted because it is also Jaavscript function at the end of the day 

ES6 is not manadatory

<Title/> is the most common syntax for using functional components, it is known as self closing tags

Very important point: each JSX element must have only one parent element so const jsx=<h1> Hi<h2> Hello </h2></h1> is invalid syntax, it shoud be wrapped inside a div like const jsx=<div><h1> Hi<h2> Hello </h2></h1> </div>

If I don't use React Fragment then the structure looks something like <div id="root"> <div> <h1> Hi </h1> <h2> Hello</h2></div></div>, the div inside div is ugly, so we use react fragement

react fragment is a component that is exported from react, if used then the strcuture looks like 
<div id="root">  <h1> Hi </h1> <h2> Hello</h2></div>, the extra div gets eliminated

for multiple elements, I can use either div or react.fragment

React.fragment is like an empty tag
React.fragment is written in short form as <>

<div style={styleObject}>
Inline styling in react, we need to pass javascript object, another way it to give the div a class with className and define the style in style.css file

Config driven UI: The frontend website is displayed using the data sent by API on backend. 
example : swiggy in bengaluru might have 10% discount and in delhi may have 50% discount

config driven UI is a huge plus point in interviews
Carousel are those images like 50% off etc which appeaer on top

Optional chaining?. TODO

props (shorthand for properties): passing props meaning passing data/properties into a component

React bundles all the passed parameters into a single object called props

{restaurant} means destructuring the props

... is spread operator in javascript which spreadss the contents of the array

Virtual DOM is not only used in React, it is a software engineering concept, virtual dom is a representnation of the DOM in our code

React does something known as reconiciliation, reconciliation uses diff algorithm to find out differences between actual DOM and virtual DOM and rerenders that small part which is different in the real DOM and virtual DOM

Whenever there are multiple tags of same type (all h1 or all div), then React doesn't know which new div has come, it will rerender all the div's because it can't distinguish between them, but by using a unique key with each div, React knows which div to re-render and so the performance of React app improves

Virtual DOM is not the actual DOM, it is a representnation of DOM

Diff algorithm finds out the difference between the DOM and virtual DOM (just like git diff)

After Rect-16, React introduced a new reconciliation engine called React Fiber

Never use index as a key in react

No key (not acceptable) <<<<<index key (okay way,use only if you don't have anything) <<unique key (best practice)

There are two ways to export in javascript: one of them is using export default
export defualt is just used to export one function.

exporting by default vs exporting by name: syntax for export by name is export const Title=()=>{
  function body
}
while importing a js file exported by name, the syntax will be import {Title} from './components/Header.js' (this is called as named import)

import {Title} from "./components/Header": This is not object destructuring, although it looks like object destructuring

import * as obj from "./components/Header": for importing all functions and then use a particular function like obj.Title

Using import from "./components/Header" or "./components/Header.js"

Some developers even prefer to use Header.jsx instead of Header.js because it contains jsx code, even that works absolutely fine.

The config file is used to put the hardcoded things of the project

If I create a search button using 
const txt="Girik"
<input type="text" className="search-input" placeholder="Search" value="{txt}"></input>, it will not accept any data from the user, the reason being that React uses one way binding, meaning that data can only flow from the code to the user but not from the user to the code

One way data binding is actually good in a sense that it makes our app predictable, because we might be using that variable at many places in the code, so the value can be changed by different values. But it creates a problem for us because we can't take input from the user. 
so I need to use onChange attribute for this function, something like: TODO

whenever I have changing variables in React, I need to use a kind of React variable called state variables (every component in React has a state)

React hook is just a javascript function at the end of the day and these functions give us some functionalities.


useState hook: const [searchText]=useState()
useState hook return an array [variable name, function to update the variable]
what is use of function useState? to create local state variables

I can't directly set the variables in the react component, I need to use function provided by useState(), something like:
const [searchText,setSearchText]=useState("KFC") and then use the function setSearchText 

in the onChange function as a callback function in: onChange={(e)=>
        {setSearchInput(e.target.value)} 
       } 

Interview question: why do we need state variables when I have local variables?
if I use a local variable let var1=11, and if I update the variable var1 to some other value like 12, then React component would not come to know that the value of local variable has been updated

So React says that at any time if we want the variables to be in sync with the UI, we need to use state variables

Entire component is re-rendered, so if we print ('render'), it will get printed (from 6th chapter of React, exploring the world 1 1080pixel), 

Whenever there is any change in the state, React quickly rerenders the entire component gets

Important concept in industry: microservices
Swiggy/uber is not made of single React app etc

In earlier days: in same project, aws, ui (jsp pages) and code to send SMS was there
for just one icon change, they had to deploy the whole project
This is called monolith architecture

The world  (newer companies are moving towards microservices architecture)

Microservice App: Separate projects for UI, logs, SMS etc
Let's say UI is running on port 1234 and API is working on port 1235
advantage: 1) seperation of concern (important term): we don't need to worry about the other microservices, what they are doing or not

The different microservices can be written in different languages like UI can be written in React, backend can be written in Java, etc

What we are making in this project is the UI microservices

So the different mictoservices can be hosted on different ports (or different URLs too):
like swiggy.com (UI) on port 3000
swiggy.com/api on port 4000
swiggy.com/notifications on port 5000

or it can be like github.com or api.github.com

Exploring the world means communication between UI microservice and API microservice

const Body = () => {
  IMPORTANT: if I call fetch() here, it will rerender on each UI update
  // const searchTxt="KFC"
  //searchText is a local state variable
  const [searchText,setSearchInput]=useState("") //to create state varibable
  return (
    <div> .....</div>
  )

There are two ways:
1) the website request is made->make an API call (say, it takes about 300 ms)->render page in React (say it takes 200 ms ) in total takes about 500 ms

2) the website request is made-> show some intial page (maybe even render the page)->make the API call-> update the UI (takes 300 ms in total let's say)

second way is a better way due to enhancing user experience

