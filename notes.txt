d<!--Anything we can generate on server like parcel-cache or node_modules should be in gitignore, but package-lock.json can't be put in gitignore-->
        <!-- React is not fast only because of virtual DOM but because of bundlers (like parcel or vite or webpack)-->
//dist folder stores the minified files 

We have a package manager which takes care of our transitive dependencies (transitive dependecies means dependecies which can further have even more dependencies)

"browsersList":[
    "last 2 versions"]
  } ensures that my app is compatiable with last 2 versions of all browsers avaialble on broswerslist.dev

  bable is used for creating polyfill
  polfyfill means replacing code with the code that browser understands
  eg. if older version of JS doesn't understand map() function, bable may write own custom implementation of map() so that code is able to execute

  tree shaking means that if I am importing a library,library may provide 10-20 functions, but I may be using only 1 or 2 of them. So parcel is smart enough and it removes the code of the unused libraries.

  babel-plugin-transform-remove-console is used for removing the console.log statements from the production code.

  .babelrc is a configuration for babel

  Whenever there there is an array in createElement like const container=React.createElement(
                "div",{
                    id:"container",
                }, [heading1,heading2]
    ), I need to use key in my props.

Updating something in DOM is called rendering

Why do I need to use key as a prop? See from the docs https://reactjs.org/docs/reconciliation.html: I will explain briefly
If I change my code from:
<ul>
  <li>first</li>
  <li>second</li>
</ul>

to:
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>

then React has to do a lot of work in rerendering, because React just knows that another li has been added. But if I add keys, React knows which new li tag has been added, so it doesn't have to spend that much time and performance of React improves.

React.createElement gives us an object which is then converted to HTML code and placed on the DOM React.createElement=>Object=>HTML (DOM)

JSX is used because for a complicated structure React.createElement code becomes lengthy and complicated when there are multiple children

JSX is HTML-like syntax but not HTML inside Javascript.

ID is a HTML concept but key is a concept from React

Babel is a JavaScript library which internally uses React.createElement from JSX

So the flow goes like:  JSX -> React.createElement -> Object-> HTML (mounted on DOM)

babel is installed along with parcel
there is second package-lock.json in node_modules which has details about versions of all transitve dependcies (babel is present in node_modules )

Everything is a component in react

Reaction based components:functional based components (new, will be taught) and class based components  is the old way of writing code

Functional based component is nothing but a normal Javascript function which can either return JSX or a React element using React.createElement

Component name starts with capital letter-- this is not mandatory but a convention

When I use a function based component, the I use the syntax as root.render(<FunctionalComponent/>)

Difference between React element and component: 
const heading=(
    <h1 id="heading3" key="abc"> Namaste React </h1>
) this is a react element but 

const heading=()=>{
    return <h1 id="heading"> Namaste React</h1>
} this is a React component (function based component)

React element at the end of the day is an object and a React functional based component is a function.

We can execute any JS code inside curly braces {console.log("Hello")} inside the React component

If I have an API that has some malicious code inside it let's call it data, and if it is called inside the React component like {data}, then malicious code gets excuted, this is known as cross site scripting. But JSX does something called sanitisation, it makes sure that the code is secure

Component compposition is nothing but placing a component inside another component

React function is also hoisted because it is also Jaavscript function at the end of the day 

ES6 is not manadatory

<Title/> is the most common syntax for using functional components, it is known as self closing tags

Very important point: each JSX element must have only one parent element so const jsx=<h1> Hi<h2> Hello </h2></h1> is invalid syntax, it shoud be wrapped inside a div like const jsx=<div><h1> Hi<h2> Hello </h2></h1> </div>

If I don't use React Fragment then the structure looks something like <div id="root"> <div> <h1> Hi </h1> <h2> Hello</h2></div></div>, the div inside div is ugly, so we use react fragement

react fragment is a component that is exported from react, if used then the strcuture looks like 
<div id="root">  <h1> Hi </h1> <h2> Hello</h2></div>, the extra div gets eliminated

for multiple elements, I can use either div or react.fragment

React.fragment is like an empty tag
React.fragment is written in short form as <>

<div style={styleObject}>
Inline styling in react, we need to pass javascript object, another way it to give the div a class with className and define the style in style.css file

Config driven UI: The frontend website is displayed using the data sent by API on backend. 
example : swiggy in bengaluru might have 10% discount and in delhi may have 50% discount

config driven UI is a huge plus point in interviews
Carousel are those images like 50% off etc which appeaer on top

Optional chaining?. TODO

props (shorthand for properties): passing props meaning passing data/properties into a component

React bundles all the passed parameters into a single object called props

{restaurant} means destructuring the props

... is spread operator in javascript which spreadss the contents of the array

Virtual DOM is not only used in React, it is a software engineering concept, virtual dom is a representnation of the DOM in our code

React does something known as reconiciliation, reconciliation uses diff algorithm to find out differences between actual DOM and virtual DOM and rerenders that small part which is different in the real DOM and virtual DOM

Whenever there are multiple tags of same type (all h1 or all div), then React doesn't know which new div has come, it will rerender all the div's because it can't distinguish between them, but by using a unique key with each div, React knows which div to re-render and so the performance of React app improves

Virtual DOM is not the actual DOM, it is a representnation of DOM

Diff algorithm finds out the difference between the DOM and virtual DOM (just like git diff)

After React-16, React introduced a new reconciliation engine called React Fiber

Never use index as a key in react

No key (not acceptable) <<<<<index key (okay way,use only if you don't have anything) <<unique key (best practice)