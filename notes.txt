d<!--Anything we can generate on server like parcel-cache or node_modules should be in gitignore, but package-lock.json can't be put in gitignore-->
        <!-- React is not fast only because of virtual DOM but because of bundlers (like parcel or vite or webpack)-->
//dist folder stores the minified files 

We have a package manager which takes care of our transitive dependencies (transitive dependecies means dependecies which can further have even more dependencies)

"browsersList":[
    "last 2 versions"]
  } ensures that my app is compatiable with last 2 versions of all browsers avaialble on broswerslist.dev

  bable is used for creating polyfill
  polfyfill means replacing code with the code that browser understands
  eg. if older version of JS doesn't understand map() function, bable may write own custom implementation of map() so that code is able to execute

  tree shaking means that if I am importing a library,library may provide 10-20 functions, but I may be using only 1 or 2 of them. So parcel is smart enough and it removes the code of the unused libraries.

  babel-plugin-transform-remove-console is used for removing the console.log statements from the production code.

  .babelrc is a configuration for babel

  Whenever there there is an array in createElement like const container=React.createElement(
                "div",{
                    id:"container",
                }, [heading1,heading2]
    ), I need to use key in my props.

Updating something in DOM is called rendering

Why do I need to use key as a prop? See from the docs https://reactjs.org/docs/reconciliation.html: I will explain briefly
If I change my code from:
<ul>
  <li>first</li>
  <li>second</li>
</ul>

to:
<ul>
  <li>first</li>
  <li>second</li>
  <li>third</li>
</ul>

then React has to do a lot of work in rerendering, because React just knows that another li has been added. But if I add keys, React knows which new li tag has been added, so it doesn't have to spend that much time and performance of React improves.

React.createElement gives us an object which is then converted to HTML code and placed on the DOM React.createElement=>Object=>HTML (DOM)

JSX is used because for a complicated structure React.createElement code becomes lengthy and complicated when there are multiple children

JSX is HTML-like syntax but not HTML inside Javascript.

ID is a HTML concept but key is a concept from React

Babel is a JavaScript library which internally uses React.createElement from JSX

So the flow goes like:  JSX -> React.createElement -> Object-> HTML (mounted on DOM)

babel is installed along with parcel
there is second package-lock.json in node_modules which has details about versions of all transitve dependcies (babel is present in node_modules )

tilde (~) notation: It is used to match the most recent patch version. Tilde ~ notation freezes the major version and minor version. As we know patch updates are bug fixes that’s why we can say ~ notation allows us to automatically accept bug fixes.

Caret (^) notation: It is used for automatically updating the minor updates along with patch updates. 

Everything is a component in react

Reaction based components:functional based components (new, will be taught) and class based components  is the old way of writing code

Functional based component is nothing but a normal Javascript function which can either return JSX or a React element using React.createElement

Component name starts with capital letter-- this is not mandatory but a convention

When I use a function based component, the I use the syntax as root.render(<FunctionalComponent/>)

Difference between React element and component: 
const heading=(
    <h1 id="heading3" key="abc"> Namaste React </h1>
) this is a react element but 

const heading=()=>{
    return <h1 id="heading"> Namaste React</h1>
} this is a React component (function based component)

React element at the end of the day is an object and a React functional based component is a function.

We can execute any JS code (any JS aexpression not statement) inside curly braces {console.log("Hello")} inside the React component
for example, the code {
  let a=10;
  console.log(a) will not work, because these are two js statements
}
but if we convert it into a js expression, something like ((a=10),console.log(a)) it will work

If I have an API that has some malicious code inside it let's call it data, and if it is called inside the React component like {data}, then malicious code gets excuted, this is known as cross site scripting. But JSX does something called sanitisation, it makes sure that the code is secure

Component compposition is nothing but placing a component inside another component

React function is also hoisted because it is also Jaavscript function at the end of the day 

ES6 is not manadatory

<Title/> is the most common syntax for using functional components, it is known as self closing tags

Very important point: each JSX element must have only one parent element so const jsx=<h1> Hi<h2> Hello </h2></h1> is invalid syntax, it shoud be wrapped inside a div like const jsx=<div><h1> Hi<h2> Hello </h2></h1> </div>

If I don't use React Fragment then the structure looks something like <div id="root"> <div> <h1> Hi </h1> <h2> Hello</h2></div></div>, the div inside div is ugly, so we use react fragement

react fragment is a component that is exported from react, if used then the strcuture looks like 
<div id="root">  <h1> Hi </h1> <h2> Hello</h2></div>, the extra div gets eliminated

for multiple elements, I can use either div or react.fragment

React.fragment is like an empty tag
React.fragment is written in short form as <>

<div style={styleObject}>
Inline styling in react, we need to pass javascript object, another way it to give the div a class with className and define the style in style.css file

Config driven UI: The frontend website is displayed using the data sent by API on backend. 
example : swiggy in bengaluru might have 10% discount and in delhi may have 50% discount

config driven UI is a huge plus point in interviews
Carousel are those images like 50% off etc which appeaer on top

Optional chaining?. TODO

props (shorthand for properties): passing props meaning passing data/properties into a component

React bundles all the passed parameters into a single object called props

{restaurant} means destructuring the props

... is spread operator in javascript which spreadss the contents of the array

Virtual DOM is not only used in React, it is a software engineering concept, virtual dom is a representnation of the DOM in our code

React does something known as reconiciliation, reconciliation uses diff algorithm to find out differences between actual DOM and virtual DOM and rerenders that small part which is different in the real DOM and virtual DOM

Whenever there are multiple tags of same type (all h1 or all div), then React doesn't know which new div has come, it will rerender all the div's because it can't distinguish between them, but by using a unique key with each div, React knows which div to re-render and so the performance of React app improves

Virtual DOM is not the actual DOM, it is a representnation of DOM

Diff algorithm finds out the difference between the DOM and virtual DOM (just like git diff)

After Rect-16, React introduced a new reconciliation engine called React Fiber

Never use index as a key in react

No key (not acceptable) <<<<<index key (okay way,use only if you don't have anything) <<unique key (best practice)

There are two ways to export in javascript: one of them is using export default
export defualt is just used to export one function.

exporting by default vs exporting by name: syntax for export by name is export const Title=()=>{
  function body
}
while importing a js file exported by name, the syntax will be import {Title} from './components/Header.js' (this is called as named import)

import {Title} from "./components/Header": This is not object destructuring, although it looks like object destructuring

import * as obj from "./components/Header": for importing all functions and then use a particular function like obj.Title

Using import from "./components/Header" or "./components/Header.js"

Some developers even prefer to use Header.jsx instead of Header.js because it contains jsx code, even that works absolutely fine.

The config file is used to put the hardcoded things of the project

If I create a search button using 
const txt="Girik"
<input type="text" className="search-input" placeholder="Search" value="{txt}"></input>, it will not accept any data from the user, the reason being that React uses one way binding, meaning that data can only flow from the code to the user but not from the user to the code

One way data binding is actually good in a sense that it makes our app predictable, because we might be using that variable at many places in the code, so the value can be changed by different values. But it creates a problem for us because we can't take input from the user. 
so I need to use onChange attribute for this function, something like: TODO

whenever I have changing variables in React, I need to use a kind of React variable called state variables (every component in React has a state)

React hook is just a javascript function at the end of the day and these functions give us some functionalities.


useState hook: const [searchText]=useState()
useState hook return an array [variable name, function to update the variable]
what is use of function useState? to create local state variables

I can't directly set the variables in the react component, I need to use function provided by useState(), something like:
const [searchText,setSearchText]=useState("KFC") and then use the function setSearchText 

in the onChange function as a callback function in: onChange={(e)=>
        {setSearchInput(e.target.value)} 
       } 

Interview question: why do we need state variables when I have local variables?
if I use a local variable let var1=11, and if I update the variable var1 to some other value like 12, then React component would not come to know that the value of local variable has been updated

So React says that at any time if we want the variables to be in sync with the UI, we need to use state variables

Entire component is re-rendered, so if we print ('render'), it will get printed (from 6th chapter of React, exploring the world 1 1080pixel), 

Whenever there is any change in the state, React quickly rerenders the entire component gets

Important concept in industry: microservices
Swiggy/uber is not made of single React app etc

In earlier days: in same project, aws, ui (jsp pages) and code to send SMS was there
for just one icon change, they had to deploy the whole project
This is called monolith architecture

The world  (newer companies are moving towards microservices architecture)

Microservice App: Separate projects for UI, logs, SMS etc
Let's say UI is running on port 1234 and API is working on port 1235
advantage: 1) seperation of concern (important term): we don't need to worry about the other microservices, what they are doing or not

The different microservices can be written in different languages like UI can be written in React, backend can be written in Java, etc

What we are making in this project is the UI microservices

So the different mictoservices can be hosted on different ports (or different URLs too):
like swiggy.com (UI) on port 3000
swiggy.com/api on port 4000
swiggy.com/notifications on port 5000

or it can be like github.com or api.github.com

Exploring the world means communication between UI microservice and API microservice

const Body = () => {
  IMPORTANT: if I call fetch() here, it will rerender on each UI update
  // const searchTxt="KFC"
  //searchText is a local state variable
  const [searchText,setSearchInput]=useState("") //to create state varibable
  return (
    <div> .....</div>
  )

There are two ways:
1) the website request is made->make an API call (say, it takes about 300 ms)->render page in React (say it takes 200 ms ) in total takes about 500 ms

2) the website request is made-> show some intial page (maybe even render the page)->make the API call-> update the UI (takes 300 ms in total let's say)

second way is a better way due to enhancing user experience

useEffect is a hook for accomplishing the second way (rendering a page first, call and API and then updating in the UI)

in useEffect() function, we pass a callback function so the syntax looks something like:

useEffect(()=>{
  callback function body
})

callbac function means that the function will not be called immediately, it will be called when useEffect wants to call it

so using useEffect hook, the function for API call will be called after the code of UI has executed (the second case which we discussed above)

useEffect is imported using named import from "react"

When will component render? 2 ways: state changes or prop changes

Now there's a catch: we don't want to call the callback function after every re-render, so we use a dependency array

so overall syntax of useEffect looks like
useEffect(()=>{
  console.log("render")
},[])

use case: we want to cal useEffect only when searchText is changed

If dependency array is empty then that component will not re-reneder for any update

If empty dependency array, then console.log() will be called once after render
if dependendcy array is [searchText], then it will be called once after intitial render and everytime after render (every time searchText changes)

The optional chaining (?.) operator accesses an object's property or calls a function. If the object accessed or function called is undefined or null, it returns undefined instead of throwing an error.

When we open swiggy.com, we see some empty boxes at the first and then the restaarant cards appear
This is done to improve user experience so that the data does not appear all of a sudden on the page after the loading rotating in circular fashion

This is known as shimmer effect : https://blog.logrocket.com/implement-shimmer-effect-flutter/#:~:text=What%20is%20a%20shimmer%20effect,when%20the%20data%20is%20available. Read more about it here

Conditional rerendering: means if restaurant is empty, then load shimmer UI otherwise load actual UI

Diff algorithm is defined in React not react-dom (diff algorithm is same in react-dom and react-native for mobile applications)

If I don't specify any dependency in the useEffect hook, something like useEffect(function), it assumes dependency on each variable, so it will be called after every re-render but for empty array [], useEfffect will be called only during initial render

It's not a good idea to define a component inside another component, for example, the following code is not good:

const appLayout=()=>{
  const func=(){

  }
}
Reason: every time there is a change in appLayout, func will be rerendered too

Never use a useState hook inside a for loop or if condition(because it leads to inconsistencies)
Never use useState outside the functional component

It is completely fine to use multiple useEffect inside a functional component, but perforemance of app will go down

For using routing in React, there can be different types of routers (available in documentation) but most commonly we use createBrowserRouter 

while specifying the routing, we use path and element, path specifies the path like '/about' and element specifies which component is to be used

Just using createBrowserRouter from react-router-dom won't work because we need to provide thr router to the app, so we use, for this we use RouterProvider compoennt from react-router-dom


useRouteError is a hook provided inside react-router-dom which returns an object containgin detailed information abput why rotuing failed

Single Page applications(SPA's): in earlier days, there used to be different pages for different pages of the website lie website.com/about.html or website.com/contact.html: a network call had to be made for visiting different pages on the same website: but this is not the case with single page applications

Two types of routing in React: client side routing and server based routing
Server based routing: the new page will come from the server
client side routing: we don't make a network call, all the components are already there in the code

One way to place a link could be with anchor tag <a>, but that would reload the entire page (server side reloading)
to prevent this I use client side routing with "Link" from react-router-dom

The syntax is something like:
import { Link } from "react-router-dom"

<li> <Link to="/about"> About </Link> </li>

Behind the scenes, Link also uses anchor tag <a> (if we see in the console), but using Link from react-router-dom has the advantage that it keeps track of all the links (just like useState keeps track of all state variables)

The problem with the app till now is that if I load the about us page, the header and footer page will disappear, but I want header and footer to be there on each page, so <Header> </Header> {Outlet code} <Footer> </Footer>, the outlet code will be the code which is actually rendering according to the page (whether it is "/" or "/about" )

For using Outlet, we use Outlet from "react-router-dom"

All the children which we specify in the routing configuration will be passed to <Outlet/> according to the route used (We can call it conitional routing )

Dynamic routing: the routes are not hardcoded, but they vary according to which link I am clicking. Like on swiggy.com, if I click restaurant sagar-ratna, link will be swiggy.com/sagar-ratna and if I click on Gopal, link will be swiggy.com/Gopal

I want to build a functionality where if I visit the route localhost:1234/restaurant/123 I get the message "Welcome to restauarnt 123" and if I visit localhost:1234/restaurant/124, I get the message displayed as "Welcome to restuarnt 124"

For implementing this functionality I need to know the params which were passed, so there's a hook which is known as useParams which enables me to get the param "123" or "1234" etc

Modularity makes the code understandable, testable, readable and maintainable

===CLASS BASED COMPONENTS===
React intially started with class based components, initially there was no concept of functional based components and hooks.
Class based components makes the code somewhat messier, and it is not used in upcoming new projects, but maybe used in legacy codes.

Class based components are highly asked in interviews 

Class based components are javascript classes at the end of the day. 
The syntax for using a class based component is something like:
class Profile extends React.Component{ //I need to write extends React.component so that JS can understand it is different from a normal class (the class Profile is basically inheriting some properties from React.component)

  render() { 
      return <h1> Profile class component </h1> // return jsx
  } //calling render is the most important aspect of any class based component
  export default Profile;
}

In a class based functional component, the props are accessed as: {this.props.name} 
React attached the props to the class

For a class based functional component,for passing props, we have to define the state (similar to useState functional hook), inside the constructor of the class, and inside the class define this.state, and inside this.state define the variable like count, the sample code is given below:

constructor(props){
        super(props);
        //create state
        this.state={
            count:0,
        };
    }

If I have to create another state variable count2 in the code, it will be maintained in the same this.state object

Even using multiple useState internally maintains a single big object 

For using setCount in class based components, we use setState() method provided by JavaScript. WE CAN'T DIRECTLY MUTATE THE STATE VARIABLE, SYNTAX LIKE this.state.count=1 is INVALID

reconciliation algorithm works the same way for both class based and functional based components

So, in a class based component, we can change all the state variables with the help of a single setState() method

Order of execution in a class based component:
the constructor is called first, and then the class based functional component is called 

Now in order to mimic the useEffect functional hook (first of all, in esssence what a useEffect hook does is that the component gets rendered first and then the useEffect is called), so in class based components we have componentDidMount() function which is called after the render of the component.

The order of executionis : constructor first, then the component is rendered and then componentDidMount is called (this is known as lifecycle of React component)

Order of lifecycle method caling when parent and two children are there: (confusing question):

What I mean is something like 

Whenevr react is ernedeirng anything, two phases: first phase is render phase and second one is commit phase


First understand what exactly is meant by rendering of a component and mounting of a component.....https://www.quora.com/What-does-the-term-render-mean-in-ReactJS-Like-render-a-component In a nutshell, rendering is the process of transforming your react components into DOM (Document Object Model) nodes that your browser can understand and display on the screen.

DOM manipulation is extremely slow. In contrast, manipulating React elements is much, much faster. React makes the most of this by creating a virtual representation of what the DOM should look like called the Virtual DOM[1].

Whenever you make any changes to your running React application, such as entering text, removing an element, adding an element, etc, React will batch all of these changes together in its Virtual DOM, then compare this representation with the actual DOM, find what needs to be updated, and then make the smallest possible changes to the real DOM to keep them in sync while keeping the application performant.


===Meaning of mounting a component===
https://stackoverflow.com/questions/31556450/what-is-mounting-in-react-js

React does so by "mounting" (adding nodes to the DOM), "unmounting" (removing them from the DOM), and "updating" (making changes to nodes already in the DOM).

As making  changes in the actual DOM is a heavy operation, React tried to firstly render all the components (parent component, first component and second component), so the order of execution is like: parent component constructor, parent component render, first compomemt constructor, first component render, second component constuctor, second component render

Now, when the time comes to make the changes in the actual DOM, first component will firstly make the changes, so first component Did Mount will be called first (Because of FIFO order), then second DidMount will be called and at last parent componentDidMount will be called (parent will be called at last, because it is the parent of both the components, so it won't see FIFO order )

--IMPORTANT QUESTION ASKED IN SENIOR REACT interviews
Why can you not pass an async function directly into a React useEffect call? i.e. why something like useEffect(async f) is not allowed?

Answer taken from here: https://ultimatecourses.com/blog/using-async-await-inside-react-use-effect-hook#:~:text=Why%3F,function%20will%20never%20get%20called.

This WORKS, but you should avoid it. Why? Because React’s useEffect hook expects a cleanup function returned from it which is called when the component unmounts. Using an async function here will cause a bug as the cleanup function will never get called. 

So what excatly is a cleanup function? 

React’s useEffect cleanup function saves applications from unwanted behaviors like memory leaks by cleaning up effects. In doing so, we can optimize our application’s performance. 

Just like the name implies, the useEffect cleanup is a function in the useEffect Hook that allows us to tidy up our code before our component unmounts. When our code runs and reruns for every render, useEffect also cleans up after itself using the cleanup function.

The useEffect Hook is built in a way that we can return a function inside it and this return function is where the cleanup happens. The cleanup function prevents memory leaks and removes some unnecessary and unwanted behaviors.

ComponentDidUpdate() function is called when the component is already mounted on the DOM (the node for that component already exists in the DOM but there is some update like when we change the state using setState function)

componentDidMount will be called during first render and componentDidUpdate will be called when DOM is getting updated (this is exactl similar to what we did in useEffect, but we don't have to make the componentDidMount and componentDidUpdate functions)

there's a componentWillUnmount function too, it is called when the component is unmounted from the DOM (eg when I switch to some other page )

ONE IMPORTANT NOTE: DON'T COMPARE LIFECYCLE METHODS WITH FUNCTIONAL BASED COMPONENTS, LIKE DON'T SAY useEffect is equivalent to componentDidMount method 

If I had to mimic something like useEffect(,[count1,count2]) in class based functional components, it would be something like:

componentDidUpdate(prevProps,prevState){
  if (this.state.count1!===prevState.count1 || this.state.count2!===prevState.count2){
    //code: so this way of writing code is a pain
  }
}


===DISCUSSED IN LECTURE===
What is the use case of componentWillUnmount?
Our application has one page (single page application), when we aree clicking on Home,About, Contact etc then only the component is getting changed, the page is not getting changed


changedsetInterval(()=>{
            console.log("Namaste React OP")
        },1000)
        console.log("componentDidMount")
}
For answering why componentWillUnmount is needed (what type of cleanup is performed), consider the above code from ProfileClass.js file 

There's a slight disdavantage with SPAs that let's say if I navigate from About to Contact page etc, then Namaste React OP will be getting printed, even though I left the About page

So I need to use clearInterval in the componentWillUnmount function, by doing so the interval stops getting printed in the console when I am on some other component like Contact Us. (this is best way to explain usecase of componentWillUnmount to interviewer)

I can mimic something similar in the useEffect hook too, let me use a setInterval function in useEffect hook too (see the profile.js file), the "Girik Garg OP" will keep on getting printed even if I navigate to some other page like Contact Us.

So in order to mimic the effect of unmounting, I can return a callback function from the useEffect